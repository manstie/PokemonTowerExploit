#!/usr/bin/python
#from win32 import win32gui, win32ui, win32con, win32api
from PyQt5.QtWebEngineWidgets import QWebEnginePage, QWebEngineView, QWebEngineScript
from PyQt5.QtWidgets import QApplication
from PyQt5.QtGui import QIcon, QPixmap
from PyQt5.QtCore import QUrl, QTimer
from PyQt5.QtTest import QTest
import pyautogui
import keyboard
import os
import sys
from enum import Enum

TIMEOUT = 100 #seconds

def main():
    #the failsafe throws an exception when the mouse is moved into one of the corners of your screen
    pyautogui.FAILSAFE = False

    app = QApplication(sys.argv)
    app.setApplicationName('Pok√©mon Tower Battle')
    ico_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    app.setWindowIcon(QIcon(ico_path + os.path.sep + 'icon.ico'))

    game = GameWindow()

    #keybinds
    keyboard.add_hotkey('f5', refresh, args=(game,))    #refresh
    keyboard.add_hotkey('ctrl+q', kill, args=(app,))    #quit
    keyboard.add_hotkey('f6', game.toggleBot)           #toggle automation

    #start gui
    app.exec_()

class GameStates(Enum):
    OFF = 0
    START = 1
    TURN = 2
    END = 3

class GameWindow(QWebEngineView):

    def __init__(self, parent=None):
        super(QWebEngineView, self).__init__(parent)
        self.pixMapItem = None
        self.long_qdesktop_id = QApplication.desktop().winId()
        self.load(QUrl('https://www.facebook.com/instantgames/689199254876917/'))
        self.setFixedHeight(900)
        self.setMinimumWidth(200)
        self.setMaximumWidth(890)
        self.resize(600, 900)
        self.setCSS()
        self.show()

        self.state = GameStates.OFF
        self.placed = False
        self.timeout = 100
        self.proceed = False

        self.timer = QTimer()
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.loop)
        self.timer.start()

    def loop(self):
        if(self.state != GameStates.OFF):
            self.timeout -= 1
            if(self.timeout == 0):
                self.resize(600, 900)
                self.page().action(QWebEnginePage.Reload).trigger()
            elif(self.timeout < -20): #however long it takes the game to refresh
                self.timeout = TIMEOUT
                self.state = GameStates.START
            
            if(self.timeout < 1):
                return

            self.captureWindow()
            
            if(self.state == GameStates.START):
                #press start game button, check if pixel has changed
                print('start')
                x, y = self.getPlayNowPos()
                pixel = self.getPixel(x, y)
                
                if((abs(pixel[0] - 71) < 10 and abs(pixel[1] - 160) < 10 and abs(pixel[2] - 255) < 10) or
                  ((abs(pixel[0] - 179) < 10 and abs(pixel[1] - 216) < 10 and abs(pixel[2] - 255) < 10))):
                    pyautogui.click(x=x, y=y)
                else:
                    self.state = GameStates.TURN
                    self.resize(890, 900);

            elif(self.state == GameStates.TURN):
                print('turn')
                x, y =  self.getButtonPos()
                pixel = self.getPixel(x, y)
                #enemy turn
                if(self.placed and abs(pixel[0] - 184) < 8 and abs(pixel[1] - 26) < 8 and abs(pixel[2] - 19) < 8):
                    if(self.width() > 400):
                       self.resize(200, 900)
                    else:
                        self.resize(890, 900);
                    self.placed = False

                #your turn
                elif((abs(pixel[0] - 253) < 8 and abs(pixel[1] - 75) < 8 and abs(pixel[2] - 11) < 8) or
                      abs(pixel[0] - 139) < 8 and abs(pixel[1] - 42) < 8 and abs(pixel[2] - 7) < 8):
                    #click drop
                    pyautogui.click(x=x, y=y)
                    self.placed = True

                #game end screen
                else:
                    #check a pixel for the game end screen
                    x, y = self.getLvlClosePos()
                    y += 100
                    pixel = self.getPixel(x, y)                    
                    if(pixel > (14, 110, 224) and pixel < (50, 120, 240)):
                        self.resize(600, 900)
                        self.state = GameStates.END

            elif(self.state == GameStates.END):
                print('end')
                #close popups
                x, y = self.getNotifFirePos()
                if(self.getPixel(x, y) > (250, 250, 250)):
                    pyautogui.click(x, y)
                    return None #return to reduce indentation

                x, y = self.getNotifSurpassPos()
                if(self.getPixel(x, y) > (250, 250, 250)):
                    pyautogui.click(x, y)
                    return None

                x, y = self.getLvlClosePos()
                if(self.getPixel(x, y) > (250, 250, 250)):
                    pyautogui.click(x, y)
                    return None

                x, y = self.getLeagueClosePos()
                if(self.getPixel(x, y) > (250, 250, 250)):
                    pyautogui.click(x, y)
                    return None

                x, y = self.getButtonPos()
                pixel = self.getPixel(x, y)
                #check if ad is overlaying 
                #screen grabs (60, 60, 60) for one frame when ad is overlaid after clicking play
                if(abs(pixel[0] - 127) < 8 and abs(pixel[1] - 59) < 8 and abs(pixel[2] - 30) < 8):
                    x, y = self.getAdClosePos()
                    pyautogui.click(x=x, y=y)

                    self.proceed = True

                #play again button
                elif((abs(pixel[0] - 253) < 8 and abs(pixel[1] - 75) < 8 and abs(pixel[2] - 11) < 8) or
                      abs(pixel[0] - 139) < 8 and abs(pixel[1] - 42) < 8 and abs(pixel[2] - 7) < 8):
                    pyautogui.click(x=x, y=y)

                    self.proceed = True

                elif(self.proceed):
                    self.proceed = False
                    #pixel = getPixel(x, y+50)
                    #if(abs(pixel[0] - 14) < 8 and abs(pixel[1] - 110) < 8 and abs(pixel[2] - 224) < 8):
                    self.timeout = TIMEOUT
                    self.resize(890, 900)
                    self.state = GameStates.TURN


    def toggleBot(self):
        self.timeout = TIMEOUT
        if(self.state == GameStates.OFF):
            self.state = GameStates.START
        else:
            self.state = GameStates.OFF

    def setCSS(self):
        SCRIPT = """
        var style = document.createElement('style');
        style.innerHTML = `
        ._n3{
            margin: 0 !important;
            width: 100% !important;
        }

        ._3_pc{
            max-width: none !important;
            min-width: none !important;
        }

        ._3_pc._30u8{
            height: 99.5vh !important;
            max-width: none !important;
            min-width: none !important;
        }
        `;
        document.head.appendChild(style);
        """

        #view.page().runJavaScript(SCRIPT, QWebEngineScript.ApplicationWorld)
        #inject script, run on document ready
        script = QWebEngineScript()
        script.setName("fullScreenGame")
        script.setSourceCode(SCRIPT)
        script.setInjectionPoint(QWebEngineScript.DocumentReady)
        #script.setRunsOnSubFrames(True)
        script.setWorldId(QWebEngineScript.ApplicationWorld)
        self.page().scripts().insert(script)

    #https://rosettacode.org/wiki/Color_of_a_screen_pixel
    def captureWindow(self):
        self.screenCap = self.screen().grabWindow(self.long_qdesktop_id).toImage()

    def getPixel(self, x, y):
        long_colour = self.screenCap.pixel(x, y)
        i_colour = int(long_colour)
        return ((i_colour >> 16) & 0xff), ((i_colour >> 8) & 0xff), (i_colour & 0xff)

    #window position functions
    def getWindowX(self):
        return self.geometry().x()

    def getWindowY(self):
        return self.geometry().y()

    def getWindowWidth(self):
        return self.width()

    def getWindowHeight(self):
        return self.height()

    def getWindowCenter(self):
        x = self.width() // 2 + self.geometry().x()
        y = self.height() // 2 + self.geometry().y()
        return (x, y)

    def getWindowN(self):
        x = self.width() // 2 + self.geometry().x()
        y = self.geometry().y()
        return (x, y)

    def getWindowNE(self):
        x = self.width() + self.geometry().x()
        y = self.geometry().y()
        return (x,y)

    def getWindowE(self):
        x = self.width() + self.geometry().x()
        y = self.height() // 2 + self.geometry().y()
        return (x, y)

    def getWindowSE(self):
        x = self.width() + self.geometry().x()
        y = self.height() + self.geometry().y()
        return (x, y)

    def getWindowS(self):
        x = self.width() // 2 + self.geometry().x()
        y = self.height() + self.geometry().y()
        return (x, y)

    def getWindowSW(self):
        x = self.geometry().x()
        y = self.height() + self.geometry().y()
        return (x, y)

    def getWindowW(self):
        x = self.geometry().x()
        y = self.height() // 2 + self.geometry().y()
        return (x, y)

    def getWindowNW(self):
        x = self.geometry().x()
        y = self.geometry().y()
        return (x, y)

    #positions around the screen for buttons relative to 600x900 resolution
    def getPlayNowPos(self):
        x, y = self.getWindowS()
        x -= 115
        y -= 260
        return (x, y)

    #ad x rgb > (200, 200, 200)
    def getAdClosePos(self):
        x, y = self.getWindowCenter()
        #if the window is thin, use the relative left position, else use center
        x = max(self.geometry().x() + 27, x-223)
        y -= 171
        return (x, y)

    #drop or enemy turn
    def getButtonPos(self):
        x, y = self.getWindowS()
        if(self.width() < 400):
            y -= 21
        else: #regular position
            y -= 50
        return (x, y)
    
    #level up screen
    def getLvlClosePos(self):
        x, y = self.getWindowNW()
        x += 50
        y += 40
        return (x, y)

    #new league screen
    def getLeagueClosePos(self):
        x, y = self.getWindowNW()
        x += 58
        y += 54
        return (x, y)

    #notification popup "you surpassed x"
    def getNotifSurpassPos(self):
        x, y = self.getWindowNW()
        x += 518
        y += 123
        return (x, y)
    
    #notification popup "you are on fire"
    def getNotifFirePos(self):
        x, y = self.getWindowNW()
        x += 518
        y += 184
        return (x, y)


def refresh(view):
    #view.reload() #crashes
    view.page().action(QWebEnginePage.Reload).trigger()

def kill(app):
    app.quit()
    os._exit(1)


if __name__ == "__main__":
    main()