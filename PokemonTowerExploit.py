#!/usr/bin/python
#from win32 import win32gui, win32ui, win32con, win32api
from PyQt5.QtWebEngineWidgets import QWebEnginePage, QWebEngineView, QWebEngineScript
from PyQt5.QtWidgets import QApplication
from PyQt5.QtGui import QIcon, QPixmap
from PyQt5.QtCore import QUrl, QRunnable, QThread, QObject, QTimer
from PyQt5.QtTest import QTest
import pyautogui
import keyboard
import os
import sys
from enum import Enum

def main():
    app = QApplication(sys.argv)
    app.setApplicationName('PokÃ©mon Tower Battle')
    ico_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    app.setWindowIcon(QIcon(ico_path + os.path.sep + 'icon.ico'))

    game = GameWindow()

    #keybinds
    keyboard.add_hotkey('f5', refresh, args=(game,))    #refresh
    keyboard.add_hotkey('ctrl+q', kill, args=(app,))    #quit
    keyboard.add_hotkey('f6', game.toggleBot)           #toggle automation

    #start gui
    app.exec_()

class GameStates(Enum):
    OFF = 0
    START = 1
    TURN = 2
    END = 3

class GameWindow(QWebEngineView):

    def __init__(self, parent=None):
        super(QWebEngineView, self).__init__(parent)
        self.pixMapItem = None
        self.long_qdesktop_id = QApplication.desktop().winId()
        self.load(QUrl('https://www.facebook.com/instantgames/689199254876917/'))
        self.setFixedHeight(900)
        self.setMinimumWidth(600)
        self.resize(600, 900)
        self.setCSS()
        self.show()

        self.state = GameStates.OFF
        self.wait = False;

        self.timer = QTimer()
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.loop)
        self.timer.start()

    def loop(self):
        if(self.state != GameStates.OFF and self.wait == False):
            self.captureWindow()
            
            if(self.state == GameStates.START):
                #press start game button, check if pixel has changed
                print('start')
                x, y = self.getPlayNowPos()
                pixel = self.getPixel(x, y)
                
                if(pixel == (206, 84, 230)):
                    pyautogui.click(x=x, y=y)
                else:
                    self.state = GameStates.TURN

            elif(self.state == GameStates.TURN):
                #
                print('turn')
                x, y =  self.getButtonPos()
                pixel = self.getPixel(x, y)
                
                #enemy turn
                if(pixel == (234, 28, 36) or pixel == (141, 33, 6)):
                    #check enemy turn counter
                    x, y = self.getTurnTimerPos()
                    pixel = self.getPixel(x, y)
                    #if the turn timer is not there, they have just played thus move the drop
                    if(pixel != (254, 5, 0)):
                        self.resize(1800, 900)
                        self.wait = True
                        #pokemon should proceed to fall off
                        QTest.qWait(3000)
                        self.wait = False
                        self.resize(600, 900)

                #your turn
                elif(pixel == (253, 119, 62)):
                    pyautogui.click(x=x, y=y)
                    self.wait = True
                    QTest.qWait(3000)
                    self.wait = False
                    #wait for your drop to land

                #game end screen
                else:
                    #check a pixel in the top left because the bottom right half
                    #already has this pixel colour when loading
                    x, y = self.getLvlClosePos()
                    pixel = self.getPixel(x, y)
                    y += 100
                    if(pixel == (14, 110, 224)):
                        self.resize(600, 900)
                        self.state = GameStates.END

            elif(self.state == GameStates.END):
                print('end')

                #close popups
                x, y = self.getNotifFirePos()
                if(self.getPixel(x, y) == (255, 188, 0)):
                    pyautogui.click(x, y)
                    return None

                x, y = self.getNotifSurpassPos()
                if(self.getPixel(x, y) == (255, 188, 0)):
                    pyautogui.click(x, y)
                    return None

                x, y = self.getLvlClosePos()
                if(self.getPixel(x, y) == (255, 188, 0)):
                    pyautogui.click(x, y)
                    return None

                x, y = self.getButtonPos()
                pixel = self.getPixel(x, y)
                #purple play again button
                if(pixel == (186, 76, 207)):
                    pyautogui.click(x=x, y=y)
                    self.wait = True
                    QTest.qWait(1500)
                    self.captureWindow()
                    #if position is blue next second then change states
                    if(self.getPixel(x, y) != (186, 76, 207)):
                        self.state = GameStates.TURN
                    self.wait = False
                elif(pixel == (93, 38, 103)):
                    #there's an ad up blocking the click, attempt to close
                    x,y = self.getAdClosePos()
                    pyautogui.click(x=x, y=y)


    def toggleBot(self):
        if(self.state == GameStates.OFF):
            self.state = GameStates.START
        else:
            self.state = GameStates.OFF


    def setCSS(self):
        SCRIPT = """
        var style = document.createElement('style');
        style.innerHTML = `
        ._n3{
            margin: 0 !important;
            width: 100% !important;
        }

        ._3_pc{
            max-width: none !important;
            min-width: none !important;
        }

        ._3_pc._30u8{
            height: 99.5vh !important;
            max-width: none !important;
            min-width: none !important;
        }
        `;
        document.head.appendChild(style);
        """

        #view.page().runJavaScript(SCRIPT, QWebEngineScript.ApplicationWorld)
        #inject script, run on document ready
        script = QWebEngineScript()
        script.setName("fullScreenGame")
        script.setSourceCode(SCRIPT)
        script.setInjectionPoint(QWebEngineScript.DocumentReady)
        #script.setRunsOnSubFrames(True)
        script.setWorldId(QWebEngineScript.ApplicationWorld)
        self.page().scripts().insert(script)

    #https://rosettacode.org/wiki/Color_of_a_screen_pixel
    def captureWindow(self):
        self.screenCap = self.screen().grabWindow(self.long_qdesktop_id).toImage()

    def getPixel(self, x, y):
        long_colour = self.screenCap.pixel(x, y)
        i_colour = int(long_colour)
        return ((i_colour >> 16) & 0xff), ((i_colour >> 8) & 0xff), (i_colour & 0xff)

    #window position functions
    def getWindowX(self):
        return self.geometry().x()

    def getWindowY(self):
        return self.geometry().y()

    def getWindowWidth(self):
        return self.width()

    def getWindowHeight(self):
        return self.height()

    def getWindowCenter(self):
        x = self.width() // 2 + self.geometry().x()
        y = self.height() // 2 + self.geometry().y()
        return (x, y)

    def getWindowN(self):
        x = self.width() // 2 + self.geometry().x()
        y = self.geometry().y()
        return (x, y)

    def getWindowNE(self):
        x = self.width() + self.geometry().x()
        y = self.geometry().y()
        return (x,y)

    def getWindowE(self):
        x = self.width() + self.geometry().x()
        y = self.height() // 2 + self.geometry().y()
        return (x, y)

    def getWindowSE(self):
        x = self.width() + self.geometry().x()
        y = self.height() + self.geometry().y()
        return (x, y)

    def getWindowS(self):
        x = self.width() // 2 + self.geometry().x()
        y = self.height() + self.geometry().y()
        return (x, y)

    def getWindowSW(self):
        x = self.geometry().x()
        y = self.height() + self.geometry().y()
        return (x, y)

    def getWindowW(self):
        x = self.geometry().x()
        y = self.height() // 2 + self.geometry().y()
        return (x, y)

    def getWindowNW(self):
        x = self.geometry().x()
        y = self.geometry().y()
        return (x, y)

    #positions around the screen for buttons relative to 600x900 resolution
    def getPlayNowPos(self):
        x, y = self.getWindowS()
        x -= 120
        y -= 180
        return (x, y)

    #ad x rgb > (200, 200, 200)
    def getAdClosePos(self):
        x, y = self.getWindowCenter()
        #if the window is thin, use the relative left position, else use center
        x = max(self.geometry().x() + 27, x-224)
        y -= 170
        return (x, y)

    #turn active = (254, 5, 0)
    def getTurnTimerPos(self):
        x, y = self.getWindowS()
        x += 24
        y -= 150
        return (x, y)

    #enemy turn = (234, 28, 36)
    #your turn = (253, 119, 62)
    #play again button active = (186, 76, 207)
    #play button while ad up = (93, 38, 103)
    def getButtonPos(self):
        x, y = self.getWindowS()
        y -= int(self.height() * 0.12)
        return (x, y)

    #level up screen active = (255, 188, 0)
    def getLvlClosePos(self):
        x, y = self.getWindowNW()
        x += 60
        y += 60
        return (x, y)

    #notification popup = (255, 188, 0)
    def getNotifSurpassPos(self):
        x, y = self.getWindowNW()
        x += 524
        y += 141
        return (x, y)
    
    #notification popup = (255, 188, 0)
    def getNotifFirePos(self):
        x, y = self.getWindowNW()
        x += 524
        y += 206
        return (x, y)


def refresh(view):
    #view.reload() #crashes
    view.page().action(QWebEnginePage.Reload).trigger()

def kill(app):
    sys.exit(app.quit())


if __name__ == "__main__":
    main()