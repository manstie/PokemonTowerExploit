#!/usr/bin/python
from PyQt5.QtWebEngineWidgets import QWebEnginePage, QWebEngineView, QWebEngineScript
from PyQt5.QtWidgets import QApplication
from PyQt5.QtGui import QIcon, QMouseEvent #, QImage
from PyQt5.QtCore import QCoreApplication, QUrl, QTimer, Qt, QPoint
#from PyQt5.QtTest import QTest

import keyboard
import os
import sys

_WIN32 = False

if os.name == 'nt':
    _WIN32 = True
    from win32 import win32gui
    import win32ui
    from ctypes import windll
    from PIL import Image

from enum import Enum

APP_NAME = 'Pokémon Tower Battle'
TIMEOUT = 100 #seconds

def main():
    app = QApplication(sys.argv)
    app.setApplicationName(APP_NAME)
    ico_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    app.setWindowIcon(QIcon(ico_path + os.path.sep + 'icon.ico'))

    game = GameWindow()

    #keybinds
    keyboard.add_hotkey('f5', refresh, args=(game,))    #refresh
    keyboard.add_hotkey('ctrl+q', kill, args=(app,))    #quit
    keyboard.add_hotkey('f6', game.toggleBot)           #toggle automation
    keyboard.add_hotkey('print screen', screenshot, args=(game,))

    #start gui
    app.exec_()

def screenshot(widget):
    path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'screenshot.png')
    if _WIN32:
        targetWindow = win32gui.FindWindow(None, APP_NAME)
        left, top, right, bot = win32gui.GetClientRect(targetWindow)
        w = right - left
        h = bot - top

        hwndDC = win32gui.GetWindowDC(targetWindow)
        mfcDC  = win32ui.CreateDCFromHandle(hwndDC)
        saveDC = mfcDC.CreateCompatibleDC()

        saveBitMap = win32ui.CreateBitmap()
        saveBitMap.CreateCompatibleBitmap(mfcDC, w, h)

        saveDC.SelectObject(saveBitMap)

        result = windll.user32.PrintWindow(targetWindow, saveDC.GetSafeHdc(), 1)

        if result != 0:
            #bmpinfo = saveBitMap.GetInfo()
            bmpstr = saveBitMap.GetBitmapBits(True)

            img = Image.frombuffer('RGB', (w, h),
                bmpstr, 'raw', 'BGRX', 0, 1)

            img.save(path)
        
            #img = img.convert("RGB")
            #data = img.tobytes("raw","RGB")

            #converting to QImage with altering window size causes crash / erroneous images
            #qimg = QImage(data, img.size[0], img.size[1], QImage.Format_RGB888)

            #qimg.save(path)
        else:
            print("Win32 failed, backup qt function used")
            widget.screenCap = widget.screen().grabWindow(widget.long_qdesktop_id,
                        widget.geometry().x(), widget.geometry().y(),
                        widget.width(), widget.height()).save(path, 'png')

        win32gui.DeleteObject(saveBitMap.GetHandle())
        saveDC.DeleteDC()
        mfcDC.DeleteDC()
        win32gui.ReleaseDC(targetWindow, hwndDC)
    else:
        widget.screenCap = widget.screen().grabWindow(widget.long_qdesktop_id,
                                    widget.geometry().x(), widget.geometry().y(),
                                    widget.width(), widget.height()).save(path, 'png')

class GameStates(Enum):
    OFF = 0
    START = 1
    TURN = 2
    END = 3

class GameWindow(QWebEngineView):

    def __init__(self, parent=None):
        super(QWebEngineView, self).__init__(parent)
        self.pixMapItem = None
        self.long_qdesktop_id = QApplication.desktop().winId()
        self.load(QUrl('https://www.facebook.com/instantgames/689199254876917/'))
        self.setFixedHeight(900)
        self.setMinimumWidth(200)
        self.setMaximumWidth(890)
        self.resize(600, 900)
        self.setCSS()
        self.show()

        self.state = GameStates.OFF
        self.placed = False
        self.timeout = 100
        self.proceed = False

        self.timer = QTimer()
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.loop)
        self.timer.start()

    def loop(self):
        if(self.state != GameStates.OFF):
            self.timeout -= 1
            if(self.timeout == 0):
                self.resize(600, 900)
                self.page().action(QWebEnginePage.Reload).trigger()
            elif(self.timeout < -20): #however long it takes the game to refresh
                self.timeout = TIMEOUT
                self.state = GameStates.START
            
            if(self.timeout < 1):
                return

            #prevent minimized crash on screen capture - window must be running
            if self.isMinimized:
                self.showNormal()

            self.captureWindow()
            
            if(self.state == GameStates.START):
                #press start game button, check if pixel has changed
                print('start')
                x, y = self.getPlayNowPos()
                pixel = self.getPixel(x, y)
                if((abs(pixel[0] - 71) < 8 and abs(pixel[1] - 160) < 8 and abs(pixel[2] - 255) < 8) or
                  ((abs(pixel[0] - 179) < 8 and abs(pixel[1] - 216) < 8 and abs(pixel[2] - 255) < 8))):
                    self.simClick(x, y)
                else:
                    self.state = GameStates.TURN
                    self.resize(890, 900);

            elif(self.state == GameStates.TURN):
                print('turn')
                x, y =  self.getButtonPos()
                pixel = self.getPixel(x, y)
                #enemy turn
                if(self.placed and abs(pixel[0] - 184) < 8 and abs(pixel[1] - 26) < 8 and abs(pixel[2] - 19) < 8):
                    if(self.width() > 400):
                       self.resize(200, 900)
                    else:
                        self.resize(890, 900);
                    self.placed = False

                #your turn
                elif((abs(pixel[0] - 253) < 8 and abs(pixel[1] - 75) < 8 and abs(pixel[2] - 11) < 8) or
                      abs(pixel[0] - 139) < 8 and abs(pixel[1] - 42) < 8 and abs(pixel[2] - 7) < 8):
                    #click drop
                    self.simClick(x, y)
                    self.placed = True

                #game end screen
                else:
                    #check a pixel for the game end screen
                    x, y = self.getLvlClosePos()
                    y += 100
                    pixel = self.getPixel(x, y)                    
                    if(pixel > (14, 110, 224) and pixel < (50, 120, 240)):
                        self.resize(600, 900)
                        self.state = GameStates.END

            elif(self.state == GameStates.END):
                print('end')
                #close popups
                x, y = self.getNotifFirePos()
                if(self.getPixel(x, y) > (250, 250, 250)):
                    self.simClick(x, y)
                    return None #return to reduce indentation

                x, y = self.getNotifSurpassPos()
                if(self.getPixel(x, y) > (250, 250, 250)):
                    self.simClick(x, y)
                    return None

                x, y = self.getLvlClosePos()
                if(self.getPixel(x, y) > (250, 250, 250)):
                    self.simClick(x, y)
                    return None

                x, y = self.getLeagueClosePos()
                if(self.getPixel(x, y) > (250, 250, 250)):
                    self.simClick(x, y)
                    return None

                x, y = self.getButtonPos()
                pixel = self.getPixel(x, y)
                #check if ad is overlaying 
                #screen grabs (60, 60, 60) for one frame when ad is overlaid after clicking play
                if(abs(pixel[0] - 127) < 8 and abs(pixel[1] - 37) < 8 and abs(pixel[2] - 7) < 8):
                    x, y = self.getAdClosePos()
                    self.simClick(x, y)

                    self.proceed = True

                #play again button
                elif((abs(pixel[0] - 253) < 8 and abs(pixel[1] - 75) < 8 and abs(pixel[2] - 11) < 8) or
                      abs(pixel[0] - 139) < 8 and abs(pixel[1] - 42) < 8 and abs(pixel[2] - 7) < 8):
                    self.simClick(x, y)

                    self.proceed = True

                elif(self.proceed):
                    self.proceed = False
                    #pixel = getPixel(x, y+50)
                    #if(abs(pixel[0] - 14) < 8 and abs(pixel[1] - 110) < 8 and abs(pixel[2] - 224) < 8):
                    self.timeout = TIMEOUT
                    self.resize(890, 900)
                    self.state = GameStates.TURN


    def toggleBot(self):
        self.timeout = TIMEOUT
        if(self.state == GameStates.OFF):
            self.state = GameStates.START
        else:
            self.state = GameStates.OFF

    def setCSS(self):
        SCRIPT = """
        var style = document.createElement('style');
        style.innerHTML = `
        ._n3{
            margin: 0 !important;
            width: 100% !important;
            display: block !important;
        }

        ._3_pc._30u8{
            height: 100vh !important;
            max-width: none !important;
            min-width: none !important;
        }
        `;
        document.head.appendChild(style);
        document.getElementById("u_0_k").remove();
        """

        #view.page().runJavaScript(SCRIPT, QWebEngineScript.ApplicationWorld)
        #inject script, run on document ready
        script = QWebEngineScript()
        script.setName("fullScreenGame")
        script.setSourceCode(SCRIPT)
        script.setInjectionPoint(QWebEngineScript.DocumentReady)
        #script.setRunsOnSubFrames(True)
        script.setWorldId(QWebEngineScript.ApplicationWorld)
        self.page().scripts().insert(script)

    #https://rosettacode.org/wiki/Color_of_a_screen_pixel
    def captureWindow(self):
        if _WIN32:
            targetWindow = win32gui.FindWindow(None, 'Pokémon Tower Battle')
            left, top, right, bot = win32gui.GetClientRect(targetWindow)
            w = right - left
            h = bot - top

            hwndDC = win32gui.GetWindowDC(targetWindow)
            mfcDC  = win32ui.CreateDCFromHandle(hwndDC)
            saveDC = mfcDC.CreateCompatibleDC()

            saveBitMap = win32ui.CreateBitmap()
            saveBitMap.CreateCompatibleBitmap(mfcDC, w, h)

            saveDC.SelectObject(saveBitMap)

            result = windll.user32.PrintWindow(targetWindow, saveDC.GetSafeHdc(), 1)

            if result != 0:
                bmpstr = saveBitMap.GetBitmapBits(True)

                self.screenCap = Image.frombuffer('RGB', (w, h), bmpstr, 'raw', 'BGRX', 0, 1)
            else:
                #backup function if windows fails
                self.screenCap = self.screen().grabWindow(self.long_qdesktop_id,
                            self.geometry().x(), self.geometry().y(),
                            self.width(), self.height()).toImage()

            win32gui.DeleteObject(saveBitMap.GetHandle())
            saveDC.DeleteDC()
            mfcDC.DeleteDC()
            win32gui.ReleaseDC(targetWindow, hwndDC)
        else:
            #must have screen on top
            self.screenCap = self.screen().grabWindow(self.long_qdesktop_id,
                                       self.geometry().x(), self.geometry().y(),
                                       self.width(), self.height()).toImage()


    def getPixel(self, x, y):
        if isinstance(self.screenCap, Image.Image):
            return self.screenCap.getpixel((x, y))
        else:
            long_colour = self.screenCap.pixel(x, y)
            i_colour = int(long_colour)
            return ((i_colour >> 16) & 0xff), ((i_colour >> 8) & 0xff), (i_colour & 0xff)

    #window position functions
    def getWindowX(self):
        return self.geometry().x()

    def getWindowY(self):
        return self.geometry().y()

    def getWindowWidth(self):
        return self.width()

    def getWindowHeight(self):
        return self.height()

    def getWindowCenter(self):
        x = self.width() // 2
        y = self.height() // 2
        return (x, y)

    def getWindowN(self):
        x = self.width() // 2
        y = 0
        return (x, y)

    def getWindowNE(self):
        x = self.width()
        y = 0
        return (x,y)

    def getWindowE(self):
        x = self.width()
        y = self.height() // 2
        return (x, y)

    def getWindowSE(self):
        x = self.width()
        y = self.height()
        return (x, y)

    def getWindowS(self):
        x = self.width() // 2
        y = self.height()
        return (x, y)

    def getWindowSW(self):
        x = 0
        y = self.height()
        return (x, y)

    def getWindowW(self):
        x = 0
        y = self.height() // 2
        return (x, y)

    def getWindowNW(self):
        x = 0
        y = 0
        return (x, y)

    #positions around the screen for buttons relative to 600x900 resolution
    def getPlayNowPos(self):
        x, y = self.getWindowS()
        x -= 115
        y -= 260
        return (x, y)

    #ad x rgb > (200, 200, 200)
    def getAdClosePos(self):
        x, y = self.getWindowCenter()
        #if the window is thin, use the relative left position, else use center
        x = max(27, x-223)
        y -= 171
        return (x, y)

    #drop or enemy turn
    def getButtonPos(self):
        x, y = self.getWindowS()
        if(self.width() < 400):
            y -= 18
        else: #regular position
            y -= 48
        return (x, y)
    
    #level up screen
    def getLvlClosePos(self):
        x, y = self.getWindowNW()
        x += 50
        y += 40
        return (x, y)

    #new league screen
    def getLeagueClosePos(self):
        x, y = self.getWindowNW()
        x += 58
        y += 54
        return (x, y)

    #notification popup "you surpassed x"
    def getNotifSurpassPos(self):
        x, y = self.getWindowNW()
        x += 518
        y += 123
        return (x, y)
    
    #notification popup "you are on fire"
    def getNotifFirePos(self):
        x, y = self.getWindowNW()
        x += 518
        y += 184
        return (x, y)

    def simClick(self, x, y):
        print("Click " + str(x) + ", " + str(y))
        #QTest.mouseClick(self, Qt.LeftButton, Qt.NoModifier, QPoint(x, y)) #doesn't work
        press = QMouseEvent(QMouseEvent.MouseButtonPress, QPoint(x, y), Qt.LeftButton, Qt.LeftButton, Qt.NoModifier )
        QCoreApplication.postEvent(self.focusProxy(), press)
        press = QMouseEvent(QMouseEvent.MouseButtonRelease, QPoint(x, y), Qt.LeftButton, Qt.LeftButton, Qt.NoModifier )
        QCoreApplication.postEvent(self.focusProxy(), press)

def refresh(view):
    #view.reload() #crashes
    view.page().action(QWebEnginePage.Reload).trigger()

def kill(app):
    app.quit()

if __name__ == "__main__":
    main()